import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';
import { dbOperations, STORES } from '@/lib/db';
import { MasterPasswordService } from './security/masterPasswordService';
import { SecureBackupStorage } from './backup/secureBackupStorage';
import { CustomerWithCredit, CreditPayment } from '@/types/credit';
import { Sale, PendingSale, PartialPayment } from '@/types/sales';
import { Product } from '@/components/pos/ProductCard';
import { User } from '@/lib/auth';
import { BackupHistoryEntry, BackupHistoryRecord } from '@/types/backup';

export interface DailySummary {
  date: string;
  reportPeriod: { start: number; end: number };
  businessName: string;
  businessLogo?: string;
  
  totalGrossSales: number;
  totalDiscounts: number;
  totalNetSales: number;
  totalTax: number;
  totalRevenue: number;
  paymentBreakdown: Record<string, number>;
  totalCash: number;
  totalCard: number;
  totalMobile: number;
  totalCredit: number;
  grandTotalReceived: number;
  totalTransactions: number;
  averageTransactionValue: number;
  
  newPendingSales: number;
  completedPendingSales: number;
  activePendingBills: number;
  totalOutstandingPending: number;
  totalPartialPaymentsToday: number;
  activePendingBillsList: Array<{
    id: string;
    customerName?: string;
    total: number;
    amountPaid: number;
    remainingBalance: number;
  }>;
  
  topProductsByQuantity: Array<{ id: string; name: string; quantity: number; revenue: number }>;
  topProductsByRevenue: Array<{ id: string; name: string; quantity: number; revenue: number }>;
  totalUnitsSold: number;
  productsBelowReorder: Array<{ id: string; name: string; stock: number; minStock: number }>;
  
  salesByCashier: Record<string, number>;
  newCustomers: number;
  returnsCount: number;
  returnsValue: number;
  
  transactions: DailyTransaction[];
}

export interface DailyTransactionItem {
  productId: string;
  productName: string;
  quantity: number;
  price: number;
  total: number;
}

export interface DailyTransaction {
  saleId: string;
  timestamp: number;
  customerName: string;
  cashierName: string;
  items: DailyTransactionItem[];
  total: number;
  paymentMethod: string;
  creditUsed: number;
}


function generateDailyReportMarkdown(summary: DailySummary): string {
  return `
# ${summary.businessName || 'Shop Name'}

## Daily Report for ${summary.date}

## Sales Summary
- Total Gross Sales: ${summary.totalGrossSales.toLocaleString('en-US')} XAF
- Total Discounts: ${summary.totalDiscounts.toLocaleString('en-US')} XAF
- Total Net Sales: ${summary.totalNetSales.toLocaleString('en-US')} XAF
- Total Tax: ${summary.totalTax.toLocaleString('en-US')} XAF
- Total Revenue: ${summary.totalRevenue.toLocaleString('en-US')} XAF
- Total Transactions: ${summary.totalTransactions}
- Average Transaction Value: ${summary.averageTransactionValue.toLocaleString('en-US')} XAF

## Top Products by Quantity
${summary.topProductsByQuantity.map(p => `- ${p.name}: ${p.quantity} units`).join('\n')}

## Top Products by Revenue
${summary.topProductsByRevenue.map(p => `- ${p.name}: ${p.revenue.toLocaleString('en-US')} XAF`).join('\n')}

## Payment Breakdown
${Object.entries(summary.paymentBreakdown).map(([method, amount]) => `- ${method}: ${amount.toLocaleString('en-US')} XAF`).join('\n')}

## New Customers: ${summary.newCustomers}
## Returns: ${summary.returnsCount} (${summary.returnsValue.toLocaleString('en-US')} XAF)

---
Generated by Tech Plus POS
`.trim();
}

export class DailyReportService {
  /**
   * Generate comprehensive daily summary data with transaction details
   */
  static async generateDailySummary(date: Date): Promise<DailySummary> {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);
    const startTimestamp = startOfDay.getTime();
    const endTimestamp = endOfDay.getTime();

    // Fetch all data
    const [allSales, allPendingSales, allPartialPayments, allProducts, allCustomers, allUsers, storeInfo] = await Promise.all([
      dbOperations.getAll<Sale>(STORES.SALES),
      dbOperations.getAll<PendingSale>(STORES.PENDING_SALES),
      dbOperations.getAll<PartialPayment>(STORES.PARTIAL_PAYMENTS),
      dbOperations.getAll<Product>(STORES.PRODUCTS),
      dbOperations.getAll<CustomerWithCredit>(STORES.CUSTOMERS),
      dbOperations.getAll<User>(STORES.USERS),
      dbOperations.get<import('@/types/settings').StoreInfo>(STORES.SETTINGS, 'store-info'),
    ]);

    // Business info: fetch from storeInfo
    let businessName = 'Your Business Name';
    let businessLogo = undefined;
    if (storeInfo) {
      businessName = storeInfo.storeName || storeInfo.name || businessName;
      businessLogo = storeInfo.logo;
    }

    
    const dailySales = allSales.filter(sale => sale.date >= startTimestamp && sale.date <= endTimestamp);
    const totalGrossSales = dailySales.reduce((sum, sale) => sum + (sale.subtotal ?? 0), 0);
    const totalDiscounts = dailySales.reduce((sum, sale) => sum + (sale.discount ?? 0), 0);
    const totalNetSales = totalGrossSales - totalDiscounts;
    const totalTax = dailySales.reduce((sum, sale) => sum + (sale.taxAmount ?? 0), 0);
    const totalRevenue = dailySales.reduce((sum, sale) => sum + (sale.total ?? 0), 0);
    const paymentBreakdown: Record<string, number> = {};
    let totalCash = 0, totalCard = 0, totalMobile = 0, totalCredit = 0;
    dailySales.forEach(sale => {
      const method = sale.paymentMethod || 'other';
      paymentBreakdown[method] = (paymentBreakdown[method] || 0) + (sale.total ?? 0);
      if (method === 'cash') totalCash += sale.total ?? 0;
      if (method === 'card') totalCard += sale.total ?? 0;
      if (method === 'mobile') totalMobile += sale.total ?? 0;
      if (method === 'credit') totalCredit += sale.total ?? 0;
    });
    const grandTotalReceived = totalCash + totalCard + totalMobile;
    const totalTransactions = dailySales.length;
    const averageTransactionValue = totalTransactions > 0 ? totalNetSales / totalTransactions : 0;

    
    const newPendingSales = allPendingSales.filter((ps) => ps.createdAt >= startTimestamp && ps.createdAt <= endTimestamp).length;
    const completedPendingSales = allPendingSales.filter((ps) => ps.status === 'archived' && ps.lastModified >= startTimestamp && ps.lastModified <= endTimestamp).length;
    const activePendingBillsList = allPendingSales.filter((ps) => !ps.isDeleted && ps.status !== 'archived' && ps.status !== 'deleted');
    const activePendingBills = activePendingBillsList.length;
    const totalOutstandingPending = activePendingBillsList.reduce((sum, ps) => sum + (ps.remainingBalance ?? 0), 0);
    const totalPartialPaymentsToday = allPartialPayments.filter((pp) => pp.processedAt >= startTimestamp && pp.processedAt <= endTimestamp).reduce((sum, pp) => sum + (pp.amount ?? 0), 0);
    const activePendingBillsListSummary = activePendingBillsList.map((ps) => ({
      id: ps.id,
      customerName: ps.customerName,
      total: ps.total,
      amountPaid: ps.amountPaid,
      remainingBalance: ps.remainingBalance
    }));

    
    
    const productSalesMap: Record<string, { name: string; quantity: number; revenue: number }> = {};
    let totalUnitsSold = 0;
    dailySales.forEach(sale => {
      sale.items.forEach((item: DailyTransactionItem) => {
        if (!productSalesMap[item.productId]) {
          productSalesMap[item.productId] = { name: item.productName, quantity: 0, revenue: 0 };
        }
        productSalesMap[item.productId].quantity += item.quantity;
        productSalesMap[item.productId].revenue += item.price * item.quantity;
        totalUnitsSold += item.quantity;
    });
    });
    const topProductsByQuantity = Object.entries(productSalesMap)
      .sort((a, b) => b[1].quantity - a[1].quantity)
      .slice(0, 5)
      .map(([id, data]) => ({ id, ...data }));
    const topProductsByRevenue = Object.entries(productSalesMap)
      .sort((a, b) => b[1].revenue - a[1].revenue)
      .slice(0, 5)
      .map(([id, data]) => ({ id, ...data }));
    
    const productsBelowReorder = allProducts.filter((p) => p.stock <= p.minStock).map((p) => ({
      id: p.id,
      name: p.name,
      stock: p.stock,
      minStock: p.minStock
    }));

    
    
    const salesByCashier: Record<string, number> = {};
    dailySales.forEach(sale => {
      const cashier = sale.cashierName || 'Unknown';
      salesByCashier[cashier] = (salesByCashier[cashier] || 0) + (sale.total ?? 0);
    });
    
    const newCustomers = allCustomers.filter((c) => c.createdAt >= startTimestamp && c.createdAt <= endTimestamp).length;
    
    const returnsCount = 0;
    const returnsValue = 0;

    
    const transactions: DailyTransaction[] = dailySales.map(sale => ({
      saleId: sale.id,
      timestamp: sale.date,
      customerName: sale.customerName || 'Guest',
      cashierName: sale.cashierName || 'Unknown',
      items: sale.items.map((item: DailyTransactionItem) => ({
        productId: item.productId,
        productName: item.productName,
        quantity: item.quantity,
        price: item.price,
        total: item.price * item.quantity
      })),
      total: sale.total,
      paymentMethod: sale.paymentMethod,
      creditUsed: sale.paymentMethod === 'credit' ? sale.total : 0
    }));

    return {
      date: date.toISOString().slice(0, 10),
      reportPeriod: { start: startTimestamp, end: endTimestamp },
      businessName,
      businessLogo,
      totalGrossSales,
      totalDiscounts,
      totalNetSales,
      totalTax,
      totalRevenue,
      paymentBreakdown,
      totalCash,
      totalCard,
      totalMobile,
      totalCredit,
      grandTotalReceived,
      totalTransactions,
      averageTransactionValue,
      newPendingSales,
      completedPendingSales,
      activePendingBills,
      totalOutstandingPending,
      totalPartialPaymentsToday,
      activePendingBillsList: activePendingBillsListSummary,
      topProductsByQuantity,
      topProductsByRevenue,
      totalUnitsSold,
      productsBelowReorder,
      salesByCashier,
      newCustomers,
      returnsCount,
      returnsValue,
      transactions
    };
  }

    static async protectPDFWithPassword(pdfData: Uint8Array, password: string): Promise<Uint8Array> {
    
    throw new Error('Password protection not implemented in browser environment');
  }

  static async generateDailyPDF(summary: DailySummary, masterPassword: string): Promise<Uint8Array> {
    const pdfDoc = await PDFDocument.create();
    let page = pdfDoc.addPage([595, 842]); 
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontSize = 11;
    const margin = 40;
    const lineHeight = 16;
    let y = 800;

    
    const markdown = generateDailyReportMarkdown(summary);
    
    const lines = markdown.split('\n');

    for (const line of lines) {
      if (y < margin) {
        y = 800;
        page = pdfDoc.addPage([595, 842]);
      }
      page.drawText(line.replace(/\*/g, ''), { x: margin, y, size: fontSize, font });
      y -= lineHeight;
      }

    return await pdfDoc.save();
  }

  /**
   * Auto-generate and save daily report
   */
  static async autoGenerateDailyReport(): Promise<boolean> {
    try {
      // Check if master password is set
      const isMasterPasswordSet = await MasterPasswordService.isSet();
      if (!isMasterPasswordSet) {
        console.log('Master password not set - cannot generate daily report');
        return false;
      }

      const today = new Date();
      const summary = await this.generateDailySummary(today);

      
      if (summary.totalTransactions === 0) {
        console.log('No sales today - skipping daily report');
        return false;
      }

      console.log('Daily report ready for generation - master password required');
      return true;
    } catch (error) {
      console.error('Error auto-generating daily report:', error);
      return false;
    }
  }

  static async generateAndSaveDailyReport(masterPassword: string, reportDate?: Date): Promise<boolean> {
    try {
      
      const isValidPassword = await MasterPasswordService.verifyPassword(masterPassword);
      if (!isValidPassword) {
        console.error('Invalid master password for daily report');
        return false;
      }

      const date = reportDate || new Date();
      const summary = await this.generateDailySummary(date);

      
      const pdfData = await this.generateDailyPDF(summary, masterPassword);
      
      
      const dateStr = summary.date;
      const fileName = `daily-report-${dateStr}.pdf`;
      
      const storageResult = await SecureBackupStorage.saveBackupFiles([
        { name: fileName, data: pdfData }
      ]);

      if (storageResult.success) {
        SecureBackupStorage.showBackupResult(
          storageResult.savedFiles,
          storageResult.errors
        );
        
        // Add to backup history
        const historyRecord = await dbOperations.get<BackupHistoryRecord>(STORES.SETTINGS, 'backup-history');
        const newEntry: BackupHistoryEntry = {
          id: `daily-report-${dateStr}`,
          timestamp: Date.now(),
          filesCreated: [fileName],
          errors: [],
          success: true,
          config: { type: 'daily-report', date: dateStr }
        };
        let entries = historyRecord?.entries || [];
        entries = [...entries, newEntry].slice(-10);
        await dbOperations.put(STORES.SETTINGS, {
          id: 'backup-history',
          entries
        });
        
        console.log('Daily report generated, saved, and recorded in history');
        return true;
      } else {
        console.error('Failed to save daily report:', storageResult.errors);
        return false;
      }
    } catch (error) {
      console.error('Error generating daily report:', error);
      return false;
    }
  }
}
